"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployBeaconImpl = exports.deployProxyImpl = void 0;
const upgrades_core_1 = require("@openzeppelin/upgrades-core");
const deploy_1 = require("./deploy");
const options_1 = require("./options");
const truffle_1 = require("./truffle");
const validations_1 = require("./validations");
const wrap_provider_1 = require("./wrap-provider");
async function getDeployData(opts, Contract) {
    const fullOpts = (0, options_1.withDefaults)(opts);
    const provider = (0, wrap_provider_1.wrapProvider)(fullOpts.deployer.provider);
    const { contracts_build_directory, contracts_directory } = (0, truffle_1.getTruffleConfig)();
    const validations = await (0, validations_1.validateArtifacts)(contracts_build_directory, contracts_directory);
    const linkedBytecode = await (0, validations_1.getLinkedBytecode)(Contract, provider);
    const encodedArgs = encodeArgs(Contract, fullOpts.constructorArgs);
    const version = (0, upgrades_core_1.getVersion)(Contract.bytecode, linkedBytecode, encodedArgs);
    const layout = (0, upgrades_core_1.getStorageLayout)([validations], version);
    return { fullOpts, validations, version, provider, layout };
}
async function deployProxyImpl(Contract, opts, proxyAddress) {
    const deployData = await getDeployData(opts, Contract);
    await (0, upgrades_core_1.processProxyKind)(deployData.provider, proxyAddress, opts, deployData.validations, deployData.version);
    let currentImplAddress;
    if (proxyAddress !== undefined) {
        // upgrade scenario
        currentImplAddress = await (0, upgrades_core_1.getImplementationAddress)(deployData.provider, proxyAddress);
    }
    return deployImpl(deployData, Contract, opts, currentImplAddress);
}
exports.deployProxyImpl = deployProxyImpl;
async function deployBeaconImpl(Contract, opts, beaconAddress) {
    const deployData = await getDeployData(opts, Contract);
    let currentImplAddress;
    if (beaconAddress !== undefined) {
        // upgrade scenario
        await (0, upgrades_core_1.assertNotProxy)(deployData.provider, beaconAddress);
        currentImplAddress = await (0, upgrades_core_1.getImplementationAddressFromBeacon)(deployData.provider, beaconAddress);
    }
    return deployImpl(deployData, Contract, opts, currentImplAddress);
}
exports.deployBeaconImpl = deployBeaconImpl;
function encodeArgs(Contract, constructorArgs) {
    var _a, _b;
    const fragment = Contract.abi.find((entry) => entry.type == 'constructor');
    return Contract.web3.eth.abi.encodeParameters((_b = (_a = fragment === null || fragment === void 0 ? void 0 : fragment.inputs) === null || _a === void 0 ? void 0 : _a.map((entry) => entry.type)) !== null && _b !== void 0 ? _b : [], constructorArgs);
}
async function deployImpl(deployData, Contract, opts, currentImplAddress) {
    (0, upgrades_core_1.assertUpgradeSafe)([deployData.validations], deployData.version, deployData.fullOpts);
    const layout = deployData.layout;
    if (currentImplAddress !== undefined) {
        const manifest = await upgrades_core_1.Manifest.forNetwork(deployData.provider);
        const currentLayout = await (0, upgrades_core_1.getStorageLayoutForAddress)(manifest, deployData.validations, currentImplAddress);
        (0, upgrades_core_1.assertStorageUpgradeSafe)(currentLayout, deployData.layout, deployData.fullOpts);
    }
    const impl = await (0, upgrades_core_1.fetchOrDeploy)(deployData.version, deployData.provider, async () => {
        const abi = Contract.abi;
        const deployment = Object.assign({ abi }, await (0, deploy_1.deploy)(deployData.fullOpts.deployer, Contract, ...deployData.fullOpts.constructorArgs));
        return { ...deployment, layout };
    });
    return { impl, kind: opts.kind };
}
//# sourceMappingURL=deploy-impl.js.map